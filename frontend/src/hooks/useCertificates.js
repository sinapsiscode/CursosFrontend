import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { useAuthStore, useProgressStore, useCourseStore, useUIStore } from '../store'
import { apiService } from '../services/api'
import { CERTIFICATES_CONFIG } from '../constants/certificatesConstants'

export const useCertificates = () => {
  const navigate = useNavigate()
  const { user, isAuthenticated } = useAuthStore()
  const { certificates, completedCourses, courseProgress } = useProgressStore()
  const { courses, setCourses } = useCourseStore()
  const { showToast } = useUIStore()

  const [loading, setLoading] = useState(true)
  const [certificatesWithDetails, setCertificatesWithDetails] = useState([])
  const [filter, setFilter] = useState('all')
  const [selectedArea, setSelectedArea] = useState('all')
  const [selectedCertificate, setSelectedCertificate] = useState(null)
  const [showPreview, setShowPreview] = useState(false)

  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/area-selection')
      return
    }
    loadCertificates()
  }, [isAuthenticated])

  const loadCertificates = async () => {
    try {
      setLoading(true)

      const allCourses = await apiService.getCourses()
      setCourses(allCourses)

      const certificatesWithCourseInfo = certificates.map(certificate => {
        const course = allCourses.find(c => c.id === certificate.courseId)
        const progress = courseProgress[certificate.courseId]

        return {
          ...certificate,
          course: course || { title: 'Curso no encontrado', area: 'unknown' },
          completedAt: certificate.completedAt || progress?.lastWatched || new Date(),
          verificationCode: `METSEL-${certificate.courseId}-${user.id}-${Date.now().toString().slice(-6)}`
        }
      })

      const existingCertCourseIds = certificates.map(cert => cert.courseId)
      const autoGeneratedCerts = completedCourses
        .filter(courseId => !existingCertCourseIds.includes(courseId))
        .map(courseId => {
          const course = allCourses.find(c => c.id === courseId)
          const progress = courseProgress[courseId]

          return {
            id: `auto_cert_${courseId}_${user.id}`,
            courseId: courseId,
            courseName: course?.title || 'Curso',
            area: course?.area || 'general',
            completedAt: progress?.lastWatched || new Date(),
            course: course,
            verificationCode: `METSEL-${courseId}-${user.id}-${Date.now().toString().slice(-6)}`,
            isAutoGenerated: true
          }
        })

      setCertificatesWithDetails([...certificatesWithCourseInfo, ...autoGeneratedCerts])

    } catch (error) {
      console.error('Error loading certificates:', error)
      showToast(CERTIFICATES_CONFIG.messages.loadError, 'error')
    } finally {
      setLoading(false)
    }
  }

  const getFilteredCertificates = () => {
    let filtered = [...certificatesWithDetails]

    if (selectedArea !== 'all') {
      filtered = filtered.filter(cert => cert.area === selectedArea)
    }

    filtered.sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))

    if (filter === 'recent') {
      const thirtyDaysAgo = new Date()
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
      filtered = filtered.filter(cert => new Date(cert.completedAt) > thirtyDaysAgo)
    }

    return filtered
  }

  const handleDownloadCertificate = async (certificate) => {
    try {
      showToast(CERTIFICATES_CONFIG.messages.generating, 'info')

      const response = await apiService.generateCertificate(user.id, certificate.courseId)

      if (response.success) {
        const link = document.createElement('a')
        link.href = response.downloadUrl
        link.download = `certificado-${certificate.courseName.replace(/\s+/g, '-').toLowerCase()}.pdf`
        link.click()

        showToast(CERTIFICATES_CONFIG.messages.downloadSuccess, 'success')
      }
    } catch (error) {
      console.error('Error downloading certificate:', error)
      showToast(CERTIFICATES_CONFIG.messages.downloadError, 'error')
    }
  }

  const handleShareCertificate = async (certificate) => {
    const shareData = {
      title: `Certificado de ${certificate.courseName}`,
      text: `Â¡He completado el curso "${certificate.courseName}" en ${CERTIFICATES_CONFIG.appNameFull}!`,
      url: `${window.location.origin}/certificate/verify/${certificate.verificationCode}`
    }

    if (navigator.share) {
      try {
        await navigator.share(shareData)
        showToast(CERTIFICATES_CONFIG.messages.shared, 'success')
      } catch (error) {
        if (error.name !== 'AbortError') {
          fallbackShare(shareData)
        }
      }
    } else {
      fallbackShare(shareData)
    }
  }

  const fallbackShare = (shareData) => {
    navigator.clipboard.writeText(`${shareData.text} ${shareData.url}`)
    showToast(CERTIFICATES_CONFIG.messages.linkCopied, 'success')
  }

  const handlePreviewCertificate = (certificate) => {
    setSelectedCertificate(certificate)
    setShowPreview(true)
  }

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  return {
    loading,
    certificatesWithDetails,
    filter,
    setFilter,
    selectedArea,
    setSelectedArea,
    selectedCertificate,
    setSelectedCertificate,
    showPreview,
    setShowPreview,
    getFilteredCertificates,
    handleDownloadCertificate,
    handleShareCertificate,
    handlePreviewCertificate,
    formatDate,
    user,
    navigate
  }
}